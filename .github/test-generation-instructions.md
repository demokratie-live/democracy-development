# Anweisungen für Test-Code-Generierung

- vitest verwenden: Generiere Tests mit dem vitest Framework. Verwende dabei die Jest-ähnliche Syntax, die vitest bereitstellt: describe-Blöcke für Test-Suiten, sowie it oder test für einzelne Testfälle und expect für Assertions. Andere Test-Frameworks (z.B. Mocha) oder nicht vorhandene Bibliotheken sollen nicht vorgeschlagen werden.
- Aussagekräftige Testbeschreibungen: Jeder Testfall sollte einen klaren Namen haben, der sein Ziel beschreibt. (Beispiel: it('should return 401 for unauthorized access', async () => { ... })). So ist unmittelbar ersichtlich, was der erwartete Output oder das Verhalten ist.
- Unit-Tests fokussieren: Copilot soll primär Unit-Tests für einzelne Funktionen oder Klassen vorschlagen. Dabei sollten externe Abhängigkeiten gemockt oder gestubbt werden. (Beispielsweise Datenbankzugriffe oder API-Aufrufe mit Dummy-Daten simulieren, damit Tests isoliert und schnell sind.)
- Edge Cases abdecken: Beim Generieren von Tests auch Randfälle und Fehlerfälle berücksichtigen. Z.B. neben dem Happy Path auch testen, wie die Funktion mit ungültigen Eingaben umgeht, ob Ausnahmen korrekt geworfen werden oder alternative Pfade funktionieren.
- React-Komponenten testen: Falls es um UI-Komponenten geht, nutze @testing-library/react zusammen mit vitest (sofern im Projekt genutzt) für Komponententests. Schlage Tests vor, die die Komponente rendern (render(<Component />)) und Benutzerinteraktionen simulieren (mit fireEvent oder userEvent). Überprüfe danach das Resultat im virtuellen DOM (screen.getBy...).
- NestJS-Module testen: Bei Backend-Code (NestJS) zeige, wie man ein TestModule erstellt und den entsprechenden Service/Controller testet. Nutze z.B. Test.createTestingModule aus NestJS, um eine isolierte Testumgebung bereitzustellen. Mocks für externe Services oder Repositories sollten eingesetzt werden, um die Logik der zu testenden Einheit in den Vordergrund zu stellen.
- Deterministische Tests: Generiere keine Tests, die zufällig scheitern können. Vermeide Abhängigkeiten von nicht deterministischen Faktoren (Zeit, Zufallswerte, externe Systeme). Falls Zeit genutzt wird, zeige die Verwendung von Jest/Vitest-Timern oder eines kontrollierten Date-Providers. Für Zufallswerte ggf. Seeding oder das Mocken der Random-Funktion vorschlagen.
- Lesbarkeit und Einfachheit: Halte Test-Code einfach und gut nachvollziehbar. Die Struktur sollte typischerweise Arrange-Act-Assert folgen: Vorbereitung der Umgebung und Daten, Ausführung der zu testenden Aktion, und Überprüfung des Ergebnisses. Vermeide unnötige Logik in Tests – sie sollten klar das Verhalten spezifizieren, nicht selbst komplex sein.
- Abdeckung sicherstellen: Weise darauf hin, dass wichtige Funktionen durch Tests abgedeckt werden. Wenn Copilot Code für neue Features generiert, sollte er nach Möglichkeit auch passende Tests vorschlagen, um die Funktionalität zu validieren. Qualität und Umfang der Tests sind entscheidend für die Maintainability.
